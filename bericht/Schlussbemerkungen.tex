\section{Schlussbemerkungen}

\subsection{Testen}
Das Testen einer Anwendung sollte immer eine sehr wichtige Rolle spielen und wurde bei unserem Projekt selbstverständlich auch durchgeführt. Wir haben keine JUnit Tests geschrieben, da uns das Konzept mit Selenium verschiedene Abläufe zu Simulieren gut gefiel. Man könnte so für jeden Testfall verschiedene Abläufe erstellen oder aus erstellten Abläufen die gesamte Anwendung lernen.  
Da wir dieses lernen erst zum Ende des Projekts durchgeführt haben wurde beim Programmieren meist über die Anwendung selbst getestet, ob kleine Codeabschnitte funktionieren. Eine weitere große Erleichterung während der Implementierung war eine extra Test-Seite (http://localhost:8080/shoutcrowd/test). Auf dieser Seite wurden grids für die im System vorhandenen User und ihre Beziehungen untereinander angelegt. Außerdem sah man die „shouts“ und konnte von dieser Seite selbst „shouts“ erstellen, Beziehungen zwischen Usern Festlegen und beim Click eines einzelnen Buttons zehn Test-User anlegen. Diese Funktionen halfen sehr die Anforderungen an die Applikation in kurzer Zeit zu testen. 
Die in der Vorlesung vorgestellten Selenium Tests erstellten wir zum abschließen Testen und gingen so verschiedene Abläufe noch explizit durch. Als Abschluss der Selenium Tests ließen wir durch den Angluin Algorithmus einen Graphen erstellen der unsere Applikation widerspiegelt.  
Leider repräsentierte der entstandene Graph unserer Ansicht nach nicht ganz unsere Anwendung, da z.B das UnfollowUser1 in keinem Fall funktionierte. Um einen vollständigen Graphen zu erstellen benutzen wir danach nur noch die sibs: CreateUsers, LoginUser1, LoginUser2, CreateMessage, LogutUser1, LogutUser2. Nicht jedoch unsere anderen Test-sibs: SearchInviteUser1, AcceptInviteFromUser2, UnfollowUser2, SearchInviteUser2, AcceptInvitefromUser1, UnfollowUser1. Wir gehen davon aus, dass es mit 12 sibs einfach zu viele Möglichkeiten gibt, sodass der Computer diese einfach nicht in angemessener Zeit komplett durchprobieren kann. 

\subsection{Ausblick}
Eine Webapplikation ist nie ganz fertig. Da die Zeit für unser Projekt jedoch begrenzt ist und die Shoutcrowd nie wirklich online gehen wird noch ein paar Worte, um zu zeigen in welche Richtung man das Projekt ausweiten könnte. Zunächst ein paar Funktionen, die in der Realität anders gelöst werden müssen:
Ein Reset der Applikation müsste normalerweise durch einen Administrator geschehen. Für einen Administrator benötigt man jedoch ein Rechtesystem und eine Extra Administratorseite. Da dies  für die reine Funktionalität nicht relevant ist haben wir es nicht implementiert. Für die Selenium Test's wird jedoch ein solcher Reset der Datenbank benutzt um durch den Angluin Algorithmus den Applikations-Graph zu lernen. Deshalb haben wir unter der URL (http://localhost:8080/shoutcrowd/wipealldata)
Eine Seite erstellt, die bei Eingabe des Richtigen Resetcode (doreset), einen Reset der Datenbank veranlasst. Des weiteren würden in der Realität Passwörter nicht im Klartext in der Datenbank gespeichert. Auch hier wurde der Einfachheit halber auf entsprechende Verschlüsselung verzichtet.

Unsere gesamte Applikation ist recht statisch es gibt kein Dynamisches Nachladen von Inhalten. Somit bekommt es der eingeloggte User nicht mit, wenn einer seiner Idols etwas neues „shouted“, es sei denn er lädt die Seite neu. Deswegen wäre für die Zukunft ein Automatisches Neuladen der Nachrichten in kleinen Zeitabständen ein nettes feature. Bei der suche könnte auch bereits beim eintippen eine Liste mit passenden Ergebnissen geladen werden, aus der man bereits auswählen kann. 
Gut wäre außerdem eine Zuordnung von Usern auf verschiedene „crowd's“ Man könnte dann die „shouts“ nach „crowd's“ sortiert anzeigen lassen und hätte so eine bessere Übersicht, gerade bei vielen Idols.
Zu guter Letzt wäre auch ein Recommender System denkbar, da unter dem Eingabefeld für die Messages noch so viel freier Platz ist könnte man diesen mit Profilbildern von anderen Usern füllen. Hier könnten Personen mit den gleichen Idols oder Personen deren Fans eigene Idols sind angezeigt werden. So wäre es einfacher neue Idols zu finden und unsere Applikation würde Sozialer.

\subsection{Fazit}
Die Shoutcrowd läuft ohne Fehler und man kann Problemlos User anlegen, Messages schreiben und andere User einladen einem selbst zu folgen. Doch bis da hin war einiges zu tun.
Die Gruppe hatte sich schnell gefunden, die meisten saßen in der ersten Vorlesung nebeneinander.
Die einzelnen Gruppenmitglieder waren von ihren Vorkenntnissen sehr inhomogen, so gab es Personen mit viel Vorwissen, die bereits eigene Webanwendungen gebaut hatten. Andere jedoch hatten sich noch nie mit Webentwicklung auseinander gesetzt  und konnten mit den Wörtern Tapestry, Maven oder Selenium nichts anfangen.
Die Entscheidung, das Versionskontrollsystem GitHub zu benutzen, war rückblickend eine sehr gute, denn ein Versionskontrollsystem ist bei einer Gruppenarbeit dieser Art fast unentbehrlich und hat vieles vereinfacht.
Außerdem waren wir gegen Freundeslisten und Freunde, da wir dies bei den beiden Listen für Fans und Idols nicht mehr für sinnvoll hielten. Die vielen Besprechungen am Anfang sorgten dafür das jedes Gruppenmitglied die gleiche Vorstellung bekam wie das Projekt grob aufgebaut werden sollte.
Wir legten gemeinsam ein Projekt und eine Erste Klassenstruktur an um auf dieser Basis Aufgabenbereiche an die einzelnen Gruppenmitglieder zu verteilen. So entstand Shoutcrowd so wie es heute ist. 
Wir trafen uns über das Semester hinweg regelmäßig um anderen Mitgliedern Zuhause erstellten Code zu erläutern oder Erkenntnisse weiterzugeben und zu helfen wo Probleme auftauchten. In Emails und einer Textdatei im Repository wurden Aufgaben, die noch zu bearbeiten waren festgehalten, damit man ihre Bearbeitung nicht vergaß. Dieses Vorgehen war, da nicht immer alle zu den treffen erscheinen konnte sehr hilfreich.
Die Zeit wurde zum Ende des Projekts etwas knapp, was aber für diese Art von Projekten normal zu sein scheint, zumal immer noch etwas verbessert werden kann.
Die Tatsache, dass alles was in der Shoutcrowd geschrieben wird von jedem User gelesen werden kann, wenn dieser nur auf das entsprechende Profil geht macht unsere Seite freier und offener für die User, die nicht viele Idols haben oder neue Leute kennen lernen möchten. So kann jeder bei jedem lesen und benötigt keine Freundschaft mit dem entsprechenden User. Die Entscheidung gegen Freundeslisten hat also viele Vorteile auch wenn uns die Verschiedenen Fan und Idol Listen anfangs etwas verwirrten.
Insgesamt verlief die Zusammenarbeit gut und gerade den Mitgliedern des Teams, die über wenig Vorkenntnisse verfügten konnte bei den vielen treffen vieles noch einmal erklärt werden, sodass das Projekt bei alles Mitgliedern des Teams viel an Erfahrung im Umgang mit den in der Vorlesung vorgestellten Technologien gebracht hat.